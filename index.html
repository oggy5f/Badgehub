<!-- === Paste this script into index.html (replace the previous script wiring wallet/mint) === -->
<script>
/* CONFIG: put your deployed address here (I used the one you shared) */
const CONFIG_CONTRACT_ADDRESS = "0xd0999A9A52270B59c341b4d87ee8c22c9633306";

/* Minimal ABI we need (lastMintTime + mint functions) - replace or extend if your contract differs */
const ABI = [
  { "inputs":[{"internalType":"address","name":"","type":"address"}],"name":"lastMintTime","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function" },
  { "inputs":[
      {"internalType":"address","name":"to","type":"address"},
      {"internalType":"string","name":"fid","type":"string"},
      {"internalType":"string","name":"badgeType_","type":"string"},
      {"internalType":"uint64","name":"date","type":"uint64"},
      {"internalType":"uint32","name":"streak","type":"uint32"},
      {"internalType":"string","name":"tokenURI_","type":"string"}
    ],
    "name":"mintBadge","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"
  },
  { "inputs":[
      {"internalType":"address","name":"to","type":"address"},
      {"internalType":"string","name":"fid","type":"string"},
      {"internalType":"uint32","name":"weekNumber","type":"uint32"},
      {"internalType":"uint64","name":"date","type":"uint64"},
      {"internalType":"uint32","name":"streak","type":"uint32"},
      {"internalType":"string","name":"tokenURI_","type":"string"}
    ],
    "name":"mintWeekBadge","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"
  }
];

/* --- Helpers to find UI elements even if IDs changed --- */
function findByIdOrText(id, textContains) {
  const byId = document.getElementById(id);
  if(byId) return byId;
  // fallback: find button that contains text
  const buttons = Array.from(document.querySelectorAll('button, a, input[type="button"], div'));
  for (const el of buttons) {
    const t = (el.innerText||el.value||"").toLowerCase();
    if(t.includes((textContains||"").toLowerCase())) return el;
  }
  return null;
}

/* Elements (tries common names) */
const btnConnect = findByIdOrText('connectBtn','connect wallet') || findByIdOrText('btnConnect','connect wallet');
const btnMintDaily = findByIdOrText('btnMintDaily','mint daily') || findByIdOrText('Mint Daily Badge Onchain','mint daily');
const btnMintWeekly = findByIdOrText('btnMintWeekly','mint weekly') || findByIdOrText('Mint Weekly Badge Onchain','mint weekly');
const statusEl = document.createElement('div');
statusEl.style.marginTop = '8px';
statusEl.style.color = '#ffae00';
statusEl.id = 'mint24Status';
(document.body.firstElementChild || document.body).prepend(statusEl);

/* UI helpers */
function setStatus(msg, color='#ffae00'){ statusEl.innerText = msg; statusEl.style.color = color; }
function disableBtn(btn){ if(btn) btn.setAttribute('disabled','true'); btn && (btn.style.opacity = 0.6); }
function enableBtn(btn){ if(btn) btn.removeAttribute('disabled'); btn && (btn.style.opacity = 1); }

/* Ethers variables */
let provider = null;
let signer = null;
let contract = null;
let connectedAccount = null;

/* 24h seconds */
const DAY_SECONDS = 24 * 60 * 60;

/* Init UI state */
function updateUIButtons(){
  // Default: disable both mint buttons until provider ready
  if(!btnMintDaily || !btnMintWeekly) {
    // If buttons not found, create console info
    console.warn('Mint buttons not found using expected selectors. Buttons are required for disabling/enable logic.');
  }
  if(!connectedAccount){
    setStatus('Wallet not connected — connect wallet to enable onchain mint.', '#ff4d4d');
    disableBtn(btnMintDaily);
    disableBtn(btnMintWeekly);
    return;
  }
  // wallet connected: check lastMintTime to decide enabling
  check24hAndToggleButtons().catch(err=>{
    console.error('Error in updateUIButtons', err);
    setStatus('Error checking mint cooldown (see console).', '#ff4d4d');
    disableBtn(btnMintDaily);
    disableBtn(btnMintWeekly);
  });
}

/* Connect wallet */
async function connectWallet(){
  try{
    if (!window.ethereum) throw new Error('MetaMask (or compatible) not found.');
    provider = new ethers.providers.Web3Provider(window.ethereum, "any");
    await provider.send("eth_requestAccounts", []);
    signer = provider.getSigner();
    connectedAccount = await signer.getAddress();
    console.log('Connected account:', connectedAccount);
    contract = new ethers.Contract(CONFIG_CONTRACT_ADDRESS, ABI, signer);
    setStatus('Wallet connected: ' + connectedAccount, '#2ecc71');
    updateUIButtons();
  }catch(err){
    console.error('connectWallet error', err);
    setStatus('Connect wallet failed. See console.', '#ff4d4d');
    disableBtn(btnMintDaily);
    disableBtn(btnMintWeekly);
  }
}

/* Check lastMintTime and toggle buttons accordingly */
async function check24hAndToggleButtons(){
  if(!contract || !connectedAccount) {
    disableBtn(btnMintDaily);
    disableBtn(btnMintWeekly);
    return;
  }
  try{
    const last = await contract.lastMintTime(connectedAccount); // returns BigNumber
    const lastTs = Number(last.toString()); // seconds since epoch - assumed
    const nowSec = Math.floor(Date.now() / 1000);
    const since = nowSec - lastTs;
    if(lastTs > 0 && since < DAY_SECONDS){
      const remaining = DAY_SECONDS - since; // seconds to wait
      const hrs = Math.floor(remaining / 3600);
      const mins = Math.floor((remaining % 3600)/60);
      const sec = remaining % 60;
      const msg = `Already minted onchain in last 24h. Wait ${hrs}h ${mins}m ${sec}s to mint again.`;
      setStatus(msg, '#ff4d4d');
      disableBtn(btnMintDaily);
      // weekly mint may be separate - keep it disabled too to be safe
      disableBtn(btnMintWeekly);
      return;
    } else {
      setStatus('Ready to mint onchain — you can mint now.', '#2ecc71');
      enableBtn(btnMintDaily);
      enableBtn(btnMintWeekly);
      return;
    }
  }catch(err){
    console.error('check24hAndToggleButtons error', err);
    // If contract does not implement lastMintTime or call fails, enable with warning
    setStatus('Could not read cooldown. Contract call failed — check console.', '#ffae00');
    enableBtn(btnMintDaily);
    enableBtn(btnMintWeekly);
  }
}

/* Mint daily onchain: checks again locally then calls contract.mintBadge(...) */
async function mintDailyOnchain(){
  if(!contract || !signer || !connectedAccount){
    alert('Connect wallet first.');
    return;
  }
  // second on-chain safety: check lastMintTime again
  try{
    const last = await contract.lastMintTime(connectedAccount);
    const lastTs = Number(last.toString());
    const nowSec = Math.floor(Date.now() / 1000);
    if(lastTs > 0 && (nowSec - lastTs) < DAY_SECONDS){
      alert('Already minted onchain in last 24 hours. Try later.');
      await check24hAndToggleButtons();
      return;
    }
  }catch(err){
    console.warn('Could not read lastMintTime — proceeding to mint (but check contract).', err);
  }

  // Prepare mint args (you likely compute date/streak/tokenURI etc in your UI; placeholder values used here)
  // Replace `fid`, `badgeType_`, `date`, `streak`, `tokenURI_` with your real data from UI
  const fid = (document.querySelector('input') && document.querySelector('input').value) || 'anon';
  const badgeType_ = 'Daily Check-in';
  const date = Math.floor(Date.now()/1000); // unix seconds
  const streak = 1; // you should compute streak from your local storage or contract data
  const tokenURI_ = ''; // optional metadata URI

  try{
    setStatus('Sending on-chain mint transaction... (confirm in wallet)', '#ffae00');
    disableBtn(btnMintDaily);
    const tx = await contract.mintBadge(connectedAccount, fid, badgeType_, date, streak, tokenURI_);
    console.log('mint tx:', tx);
    setStatus('Transaction sent — waiting for confirmation...', '#ffae00');
    await tx.wait();
    setStatus('Mint successful! Transaction mined.', '#2ecc71');
    // Update UI cooldown
    await check24hAndToggleButtons();
  }catch(err){
    console.error('mintDailyOnchain error', err);
    // Show revert reason if available
    const reason = err?.error?.message || err?.message || JSON.stringify(err);
    setStatus('Mint failed: see console for details.', '#ff4d4d');
    alert('Mint failed: ' + (reason || 'unknown'));
    // Re-enable button so user can retry (but only after inspecting)
    await check24hAndToggleButtons();
  }
}

/* Mint weekly onchain wrapper (similar check; you may want gating for streak >=7) */
async function mintWeeklyOnchain(){
  // if you want to require streak >= 7, check local UI or contract then return
  // For now same flow:
  if(!contract || !signer || !connectedAccount){
    alert('Connect wallet first.');
    return;
  }
  // Example gating: require local 'streak' value >=7 (replace with your logic)
  // const localStreak = parseInt(localStorage.getItem('badge_streak')||'0',10);
  // if(localStreak < 7){ alert('Weekly mint allowed only after 7 consecutive days.'); return; }

  // Proceed to call mintWeekBadge
  const fid = (document.querySelector('input') && document.querySelector('input').value) || 'anon';
  const weekNumber = 1;
  const date = Math.floor(Date.now()/1000);
  const streak = 7;
  const tokenURI_ = '';

  try{
    setStatus('Sending weekly mint tx... confirm in wallet.', '#ffae00');
    disableBtn(btnMintWeekly);
    const tx = await contract.mintWeekBadge(connectedAccount, fid, weekNumber, date, streak, tokenURI_);
    await tx.wait();
    setStatus('Weekly mint successful!', '#2ecc71');
    await check24hAndToggleButtons();
  }catch(err){
    console.error('mintWeeklyOnchain error', err);
    setStatus('Weekly mint failed (see console).', '#ff4d4d');
    await check24hAndToggleButtons();
  }
}

/* Attach events (safe attach using found elements) */
if(btnConnect) btnConnect.addEventListener('click', connectWallet);
if(btnMintDaily) btnMintDaily.addEventListener('click', mintDailyOnchain);
if(btnMintWeekly) btnMintWeekly.addEventListener('click', mintWeeklyOnchain);

/* On load try to auto-create provider if window.ethereum exists (optional) */
(async function boot(){
  try{
    if(window.ethereum){
      // Try to create provider but do NOT auto-request accounts (we wait for user click)
      provider = new ethers.providers.Web3Provider(window.ethereum, "any");
      // If accounts already connected (some browsers remember) - safe to request
      try{
        const accounts = await provider.listAccounts();
        if(accounts && accounts.length>0){
          signer = provider.getSigner();
          connectedAccount = await signer.getAddress();
          contract = new ethers.Contract(CONFIG_CONTRACT_ADDRESS, ABI, signer);
          setStatus('Wallet auto-detected: ' + connectedAccount, '#2ecc71');
        } else {
          setStatus('UI ready. Connect wallet to enable onchain mint.', '#ffae00');
        }
      }catch(err){ console.warn('No accounts auto-detected'); setStatus('UI ready. Connect wallet to enable onchain mint.', '#ffae00'); }
    } else {
      setStatus('No injected wallet found. Install MetaMask to enable onchain mint.', '#ff4d4d');
    }
  }catch(err){
    console.error('boot error', err);
    setStatus('Initialization error (console).', '#ff4d4d');
  } finally {
    updateUIButtons();
  }
})();
</script>
