<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Badgehub Daily & Weekly</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{font-family:Inter,system-ui,Segoe UI,Arial;background:#071017;color:#dfeff6;padding:28px;}
    .wrap{max-width:760px;margin:0 auto}
    input[type=text]{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:#0b1418;color:#fff;margin-bottom:12px}
    button{padding:12px 16px;border-radius:10px;border:0;background:#1e9cff;color:#fff;margin-right:8px;cursor:pointer}
    button.secondary{background:#444}
    .muted{color:#9fb0bf;margin-top:10px}
    .status{margin-top:12px;padding:10px;border-radius:8px;background:rgba(255,255,255,0.03);color:#bfe6c9}
    .error{color:#ff9fa0;background:rgba(255,100,100,0.06);padding:8px;border-radius:6px}
  </style>
  <!-- ethers v5 CDN -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.min.js"></script>
</head>
<body>
  <div class="wrap">
    <h1>Badgehub Daily & Weekly</h1>

    <label>Your FID / name</label>
    <input id="fid" type="text" placeholder="enter your FID (e.g. anon)" />

    <div>
      <button id="connectBtn">Connect Wallet</button>
      <button id="refreshBtn" class="secondary">Refresh</button>
    </div>

    <div style="margin-top:14px;">
      <button id="localClaimBtn" class="secondary">Claim Today's Badge (local)</button>
      <button id="mintDailyBtn">Mint Daily Badge Onchain</button>
      <button id="mintWeekBtn">Mint Weekly Badge Onchain</button>
    </div>

    <div id="status" class="status">UI initializing...</div>
    <div id="preview" style="margin-top:14px">Preview: -</div>
    <div id="errorBox" style="margin-top:12px"></div>

    <div class="muted">Tip: "local" claim stores data in browser (for testing). Onchain mint will call the smart contract.</div>
  </div>

<script>
(async function(){
  // ---------- CONFIG ----------
  const CONFIG_CONTRACT_ADDRESS = "0xd0999A9A52270B59c341b4d87ee8c22c9633306"; // <- your deployed contract
  // ABI (trimmed/used from the ABI you shared - must include mintBadge & mintWeekBadge)
  const ABI = [
    {"inputs":[],"stateMutability":"nonpayable","type":"constructor"},
    {"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"string","name":"fid","type":"string"},{"internalType":"string","name":"badgeType_","type":"string"},{"internalType":"uint64","name":"date","type":"uint64"},{"internalType":"uint32","name":"streak","type":"uint32"},{"internalType":"string","name":"tokenURI_","type":"string"}],"name":"mintBadge","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},
    {"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"string","name":"fid","type":"string"},{"internalType":"uint32","name":"weekNumber","type":"uint32"},{"internalType":"uint64","name":"date","type":"uint64"},{"internalType":"uint32","name":"streak","type":"uint32"},{"internalType":"string","name":"tokenURI_","type":"string"}],"name":"mintWeekBadge","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},
    // some helpful read functions
    {"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"lastMintTime","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
    {"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"tokenURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"}
  ];

  // ---------- DOM ----------
  const statusEl = document.getElementById('status');
  const errorBox = document.getElementById('errorBox');
  const preview = document.getElementById('preview');
  const fidInput = document.getElementById('fid');
  const connectBtn = document.getElementById('connectBtn');
  const refreshBtn = document.getElementById('refreshBtn');
  const localClaimBtn = document.getElementById('localClaimBtn');
  const mintDailyBtn = document.getElementById('mintDailyBtn');
  const mintWeekBtn = document.getElementById('mintWeekBtn');

  let provider = null;
  let signer = null;
  let account = null;
  let contract = null;

  function setStatus(txt){ statusEl.innerText = txt; }
  function setError(txt){ errorBox.innerHTML = txt ? '<div class="error">'+txt+'</div>':''; }

  // Safe provider init
  async function initProvider(){
    try{
      if(window.ethereum){
        provider = new ethers.providers.Web3Provider(window.ethereum, "any");
        setStatus("Wallet provider detected. CONFIG_CONTRACT_ADDRESS: " + CONFIG_CONTRACT_ADDRESS);
        contract = new ethers.Contract(CONFIG_CONTRACT_ADDRESS, ABI, provider);
        return true;
      } else {
        setError("No injected wallet detected. Install MetaMask or use a browser with an injected ethereum provider.");
        setStatus("No injected provider");
        return false;
      }
    } catch(e){
      console.error("initProvider error", e);
      setError("Error initializing provider: " + (e && e.message ? e.message : e));
      return false;
    }
  }

  // Connect wallet
  async function connectWallet(){
    setError("");
    try{
      if(!window.ethereum) {
        setError("No injected wallet found.");
        return;
      }
      // Request accounts
      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
      account = accounts[0];
      provider = new ethers.providers.Web3Provider(window.ethereum, "any");
      signer = provider.getSigner();
      contract = new ethers.Contract(CONFIG_CONTRACT_ADDRESS, ABI, signer);
      setStatus("Connected: " + account);
      connectBtn.innerText = "Connected";
      previewUpdate();
    } catch(err){
      console.error("connectWallet error", err);
      setError("Connect wallet cancelled or failed. See console for details.");
      setStatus("Connect wallet cancelled or failed.");
    }
  }

  // Preview update (show simple preview and streak)
  function previewUpdate(){
    const fid = (fidInput.value || "anon").trim();
    const streak = getLocalStreak(fid);
    preview.innerHTML = `<strong>${fid}</strong><br/>Daily Check-In Â· Streak: ${streak}`;
  }

  // Simple local claim logic using localStorage per FID
  function getLocalStreak(fid){
    if(!fid) return 0;
    const key = 'badgehub_local_'+fid;
    const val = localStorage.getItem(key);
    if(!val) return 0;
    try{ return parseInt(val) || 0; } catch(e){ return 0; }
  }
  function setLocalStreak(fid, n){
    if(!fid) return;
    const key = 'badgehub_local_'+fid;
    localStorage.setItem(key, String(n));
  }

  localClaimBtn.addEventListener('click', ()=>{
    setError("");
    const fid = (fidInput.value || "anon").trim();
    if(!fid){ setError("Enter FID first."); return; }
    const now = Date.now();
    let s = getLocalStreak(fid);
    s = s + 1;
    setLocalStreak(fid, s);
    setStatus("Badge claimed locally. Streak updated: " + s);
    previewUpdate();
  });

  // Mint daily onchain: calls mintBadge(to, fid, badgeType_, date, streak, tokenURI_)
  mintDailyBtn.addEventListener('click', async ()=>{
    setError("");
    if(!signer) {
      setError("Please connect wallet first.");
      return;
    }
    const fid = (fidInput.value || "anon").trim();
    if(!fid){ setError("Enter FID first."); return; }
    try{
      setStatus("Preparing transaction...");
      // simple streak from local
      let streak = getLocalStreak(fid) || 1;
      // set date as unix seconds
      const date = Math.floor(Date.now()/1000);
      const to = await signer.getAddress();
      const badgeType = "Daily Check-in";
      const tokenURI = ""; // <-- put your metadata URI here if you have one
      const tx = await contract.mintBadge(to, fid, badgeType, date, streak, tokenURI);
      setStatus("Transaction sent. Waiting for confirmation: " + tx.hash);
      await tx.wait();
      setStatus("Mint successful: " + tx.hash);
      // optionally increment local streak after onchain mint
      setLocalStreak(fid, streak+1);
      previewUpdate();
    } catch (err) {
      console.error("mintDaily error", err);
      setError("Mint failed: " + (err && err.message ? err.message : err));
      setStatus("Mint failed.");
    }
  });

  // Mint weekly onchain: calls mintWeekBadge(to, fid, weekNumber, date, streak, tokenURI_)
  mintWeekBtn.addEventListener('click', async ()=>{
    setError("");
    if(!signer) { setError("Please connect wallet first."); return; }
    const fid = (fidInput.value || "anon").trim();
    if(!fid){ setError("Enter FID first."); return; }
    try{
      setStatus("Preparing weekly mint...");
      const to = await signer.getAddress();
      const weekNumber = 1; // change logic to compute weekNumber if you want
      const date = Math.floor(Date.now()/1000);
      const streak = getLocalStreak(fid) || 0;
      const tokenURI = "";
      const tx = await contract.mintWeekBadge(to, fid, weekNumber, date, streak, tokenURI);
      setStatus("Transaction sent. Waiting... " + tx.hash);
      await tx.wait();
      setStatus("Weekly mint successful: " + tx.hash);
    } catch(err){
      console.error("mintWeek error", err);
      setError("Weekly mint failed: " + (err && err.message ? err.message : err));
      setStatus("Mint failed.");
    }
  });

  connectBtn.addEventListener('click', connectWallet);
  refreshBtn.addEventListener('click', () => {
    previewUpdate();
    setStatus("Refreshed UI.");
    setError("");
  });

  // initialize page
  const ready = await initProvider();
  if(ready) setStatus("UI ready. CONFIG_CONTRACT_ADDRESS: " + CONFIG_CONTRACT_ADDRESS);
  previewUpdate();

  // listen for account/chain changes
  if(window.ethereum){
    window.ethereum.on('accountsChanged', (accounts) => {
      if(accounts && accounts.length) {
        account = accounts[0];
        setStatus("Account changed: " + account);
        signer = (provider ? provider.getSigner() : null);
        contract = signer ? new ethers.Contract(CONFIG_CONTRACT_ADDRESS, ABI, signer) : new ethers.Contract(CONFIG_CONTRACT_ADDRESS, ABI, provider);
      } else {
        account = null;
        signer = null;
        setStatus("Not connected");
      }
    });
    window.ethereum.on('chainChanged', (chainId) => {
      // reload recommended after chain change
      setStatus("Network/chain changed. Refresh recommended.");
    });
  }

})();
</script>
</body>
</html>
